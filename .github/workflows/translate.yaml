name: Translate Markdown Files (Ignore Front Matter)

on:
  push:
    branches:
      - main # Or your main branch
    paths:
      - 'src/posts/blog/*.md' # Trigger if ANY .md file changes in 'docs' or subdirs

jobs:
  translate_changed_files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        # Fetch depth 2 is needed to compare HEAD with the previous commit
        with:
          fetch-depth: 2

      - name: Identify changed Markdown files
        id: changed_files
        run: |
          # Compare the latest commit with the previous one
          # Filter for Added ('A') or Modified ('M') files within the path
          # Output the list of changed files, one per line
          CHANGED_MD_FILES=$(git diff --name-only --diff-filter=AM HEAD~1 HEAD -- 'src/posts/blog/*.md')

          if [[ -z "$CHANGED_MD_FILES" ]]; then
            echo "No changed Markdown files found in 'docs/' in this push. Skipping translation."
            # Set count to 0 and exit successfully
            echo "::set-output name=count::0"
            exit 0
          else
            echo "Found changed Markdown files to process:"
            echo "$CHANGED_MD_FILES"
            # Save the list for the next step (handle potential newlines)
            echo "$CHANGED_MD_FILES" > changed_files.txt
            echo "::set-output name=count::$(echo "$CHANGED_MD_FILES" | wc -l)"
          fi

      - name: Set up Python
        # Only run if changed files were found
        if: steps.changed_files.outputs.count > 0
        uses: actions/setup-python@v3
        with:
          python-version: '3.x'

      - name: Install dependencies
        # Only run if changed files were found
        if: steps.changed_files.outputs.count > 0
        run: |
          pip install requests PyYAML

      - name: Translate Changed Markdown Files
        # Only run if changed files were found
        if: steps.changed_files.outputs.count > 0
        env:
          # Optional: Set if using a self-hosted instance or specific public one
          LIBRETRANSLATE_URL: "https://libretranslate.de/translate"
        run: |
          echo "Starting translation process..."
          FILES_STAGED=0 # Counter for successfully processed files

          # Read the list of files generated in the previous step
          while IFS= read -r FILE_PATH; do
            if [[ -z "$FILE_PATH" ]]; then continue; fi # Skip empty lines

            echo "Processing: $FILE_PATH"
            # Construct the output path (e.g., docs/file.md -> docs/file_en.md)
            OUTPUT_PATH="${FILE_PATH%.md}_en.md"

            # Run the Python translation script for each file
            python3 <<EOF
          import requests
          import os
          import sys
          import re # Import regex module

          def translate_text(text, target_language="en"):
              # Skip translation if text is empty or whitespace only
              if not text or text.isspace():
                  print("Skipping translation for empty or whitespace content.")
                  return "" # Return empty string for empty input

              url = os.environ.get("LIBRETRANSLATE_URL", "https://libretranslate.de/translate")
              payload = {
                  "q": text,
                  "source": "pt", # Assuming source is always Brazilian Portuguese
                  "target": target_language,
                  "format": "text"
              }
              try:
                  response = requests.post(url, json=payload, timeout=30) # Increased timeout
                  response.raise_for_status()
                  return response.json()['translatedText']
              except requests.exceptions.RequestException as e:
                  print(f"Translation API request failed: {e}", file=sys.stderr)
                  return None # Indicate failure
              except Exception as e:
                  print(f"An unexpected error occurred during translation request: {e}", file=sys.stderr)
                  return None # Indicate failure

          def separate_front_matter(content):
              front_matter = ""
              body = content
              # Regex to find YAML front matter (--- followed by content, then ---)
              # DOTALL allows '.' to match newlines
              match = re.match(r'^---\s*$(.*?)^---\s*$(.*)', content, re.MULTILINE | re.DOTALL)
              if match:
                  # Found front matter, extract it including the delimiters
                  front_matter_content = match.group(1)
                  body = match.group(2).strip() # Get the rest of the content
                  front_matter = f"---\n{front_matter_content.strip()}\n---\n\n" # Reconstruct standard format
                  print("Separated front matter.")
              else:
                  print("No front matter found.")
              return front_matter, body

          input_file = "$FILE_PATH"
          output_file = "$OUTPUT_PATH"
          translation_successful = False

          try:
              with open(input_file, "r", encoding="utf-8") as f:
                  original_content = f.read()

              front_matter, body_content = separate_front_matter(original_content)

              if not body_content.strip():
                  print(f"No body content to translate in '{input_file}'. Writing only front matter (if any).")
                  translated_body = "" # No translation needed
              else:
                  print(f"Translating body content of '{input_file}'...")
                  translated_body = translate_text(body_content)

              # Proceed only if translation didn't explicitly fail (returned None)
              if translated_body is not None:
                  print(f"Writing translated content to '{output_file}'...")
                  with open(output_file, "w", encoding="utf-8") as f:
                      f.write(front_matter) # Write the original front matter
                      f.write(translated_body) # Write the translated body
                  translation_successful = True
                  print(f"Successfully processed '{input_file}' to '{output_file}'")
              else:
                  print(f"Translation failed for body of '{input_file}', output file not created/updated.", file=sys.stderr)
                  # Decide if failure should stop the whole process - currently it doesn't

          except FileNotFoundError:
              print(f"Error: Input file '{input_file}' not found.", file=sys.stderr)
              # Exit script with error for this file, but allow loop to continue
              sys.exit(1)
          except Exception as e:
              print(f"An error occurred processing '{input_file}': {e}", file=sys.stderr)
              # Exit script with error for this file, but allow loop to continue
              sys.exit(1)

          # Exit Python script with 0 if successful for this file, 1 otherwise
          sys.exit(0 if translation_successful else 1)

          EOF

            # Check the exit code of the Python script for the current file
            PYTHON_EXIT_CODE=$?
            if [ $PYTHON_EXIT_CODE -eq 0 ]; then
              # Add the successfully translated file to git staging
              git add "$OUTPUT_PATH"
              echo "Staged $OUTPUT_PATH"
              FILES_STAGED=$((FILES_STAGED + 1))
            else
              echo "Error during processing of $FILE_PATH (Python script exited with $PYTHON_EXIT_CODE). File not staged."
              # Optionally, you could fail the whole workflow here:
              # exit 1
            fi

          done < changed_files.txt # Read from the file list

          # Set an output indicating if any files were staged
          echo "::set-output name=files_staged::$FILES_STAGED"


      - name: Commit and push changes
        # Only run if changed files were found AND at least one was successfully processed/staged
        if: steps.changed_files.outputs.count > 0 && steps.translate_changed_files.outputs.files_staged > 0
        run: |
          # This check is technically redundant now due to the step's 'if' condition,
          # but kept for clarity / extra safety.
          if ! git diff --staged --quiet; then
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            COMMIT_MSG="Translate changed Markdown files to English (Ignore Front Matter)

            Processed files:
            $(git diff --staged --name-only)"
            echo "Committing staged files..."
            git commit -m "$COMMIT_MSG"
            echo "Pushing changes..."
            git push origin HEAD:${{ github.ref }} # Push to the same branch
          else
            echo "No files were successfully translated and staged. No commit needed."
          fi
